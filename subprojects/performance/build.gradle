/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */
plugins {
    id 'org.apache.groovy-performance'
}

performanceTests {
    versions '2.5.20',
            '3.0.14',
            '4.0.7',
            'current'

    testFiles project.files("src/files") +
            project.files('src/jmh/groovy/org/apache/groovy/bench/Ackermann.groovy') +
            project.files('src/jmh/groovy/org/apache/groovy/bench/Ary.groovy') +
            project.files('src/jmh/groovy/org/apache/groovy/bench/Fibo.groovy')
}

def jmhResultsDir = layout.buildDirectory.dir("results/jmh")

// ============================================================================
// Threshold Parameter Sweep
// ============================================================================

// ============================================================================
// Profiling Support
// ============================================================================

/**
 * Run JMH with JFR (Java Flight Recorder) profiling enabled.
 */
tasks.register('jmhProfile', JavaExec) {
    dependsOn 'jmhJar'
    group = 'benchmark'
    description = 'Run JMH benchmarks with JFR profiling enabled'

    mainClass = 'org.openjdk.jmh.Main'
    classpath = files(tasks.named('jmhJar'))

    def profileDir = layout.buildDirectory.dir("results/jmh-profile")
    def jfrFile = profileDir.map { it.file("benchmark.jfr") }

    // Reduce iterations for profiling
    args '-wi', '2'
    args '-i', '3'
    args '-f', '1'

    if (project.hasProperty('benchInclude')) {
        args '.*' + project.benchInclude + '.*'
    }

    jvmArgs '-XX:+FlightRecorder'
    jvmArgs "-XX:StartFlightRecording=duration=60s,filename=${jfrFile.get().asFile.absolutePath}"

    doFirst {
        profileDir.get().asFile.mkdirs()
        println "Running JMH with JFR profiling"
        println "JFR output will be saved to: ${jfrFile.get().asFile}"
        println ""
        println "After completion, analyze with:"
        println "  jfr print ${jfrFile.get().asFile}"
        println "  jfr summary ${jfrFile.get().asFile}"
        println "Or open in JDK Mission Control (jmc)"
    }
}

/**
 * Run JMH with GC profiler for memory analysis.
 */
tasks.register('jmhGcProfile', JavaExec) {
    dependsOn 'jmhJar'
    group = 'benchmark'
    description = 'Run JMH benchmarks with GC profiler for memory analysis'

    mainClass = 'org.openjdk.jmh.Main'
    classpath = files(tasks.named('jmhJar'))

    def outputFile = jmhResultsDir.map { it.file("gc-profile-results.txt") }

    args '-rf', 'text'
    args '-rff', outputFile.get().asFile.absolutePath
    args '-prof', 'gc'

    if (project.hasProperty('benchInclude')) {
        args '.*' + project.benchInclude + '.*'
    }

    doFirst {
        println "Running JMH with GC profiler"
        println "Results will be saved to: ${outputFile.get().asFile}"
    }
}

// ============================================================================
// Dynamic Benchmark Grouping (for CI matrix)
// ============================================================================

/**
 * Discover all JMH benchmarks from the fat jar and group them by subpackage
 * into appropriately-sized chunks for parallel CI execution.
 *
 * Outputs build/jmh-groups.json — an array of {group, pattern} objects.
 */
tasks.register('jmhGroups') {
    group = 'benchmark'
    description = 'Discover JMH benchmarks and output groups as JSON for CI matrix'
    dependsOn 'jmhJar'

    def outputFile = layout.buildDirectory.file("jmh-groups.json")
    outputs.file(outputFile)

    doLast {
        // Time estimate: 1 fork × (1 warmup @10s + 1 iteration @10s) + ~5s overhead
        def secondsPerMethod = 25
        def maxSecondsPerJob = 600 // 10-minute target
        def maxPerGroup = (maxSecondsPerJob / secondsPerMethod)

        // List all benchmarks from the fat jar
        def benchmarks = providers.javaexec {
            mainClass = 'org.openjdk.jmh.Main'
            classpath = files(tasks.named('jmhJar'))
            args '-l'
        }.standardOutput.asText.get().readLines()
            .collect { it.trim() }
            .findAll { it.startsWith('org.apache.groovy.') }

        // Group by subpackage: bench.dispatch.* → "dispatch", bench.Foo → "core", plugin.* → "plugin"
        def groups = benchmarks.groupBy { fqcn ->
            def parts = (fqcn - 'org.apache.groovy.').split('\\.')
            parts[0] == 'bench' ? (parts.length >= 4 ? parts[1] : 'core') : parts[0]
        }.sort()

        // Build entries, splitting large groups into right-sized chunks by class
        def entries = groups.collectMany { name, methods ->
            if (methods.size() <= maxPerGroup) {
                def pattern = name == 'core'
                    ? ".*(" + methods.collect { it.split('\\.')[-2] }.unique().sort().join('|') + ").*"
                    : ".*\\.${name}\\..*"
                return [[group: name, pattern: pattern, benchmarks: methods.size()]]
            }
            methods.groupBy { it.split('\\.')[-2] }.sort()
                .inject([[classes: [], count: 0]]) { chunks, cls, meths ->
                    def last = chunks.last()
                    if (last.count + meths.size() > maxPerGroup && last.classes) {
                        chunks << [classes: [cls], count: meths.size()]
                    } else {
                        last.classes << cls
                        last.count += meths.size()
                        chunks
                    }
                }.withIndex(1).collect { chunk, i ->
                    [group: "${name}-${i}", pattern: ".*(" + chunk.classes.join('|') + ").*", benchmarks: chunk.count]
                }
        }

        def json = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(entries))
        outputFile.get().asFile.text = json
        println json
    }
}
